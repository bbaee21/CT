# Diagonal Difference



```
def diagonalDifference(arr):
    # Write your code here
    left_to_right = 0
    right_to_left = 0
    
    for i in range(len(arr)):
        for j in range(len(arr)):
            if (len(arr) - len(arr) + i) == (len(arr) - len(arr) + j):
                left_to_right += arr[i][j]
            if (len(arr) - len(arr) + i) == (len(arr) - 1 - j):
                right_to_left += arr[i][j]
    
    res = abs(left_to_right - right_to_left)
    
    return res
```



```
좌측 위에서 우측 아래로 대각선, 우측 위에서 좌측 아래로 대각선의 수들의 합을 구하고,
합 간의 차의 절대값을 찾는 문제.
(ex. 
	1 1 2                    좌 -> 우 : 1 + 3 + 4 = 8 
	3 3 4                    우 -> 좌 : 2 + 3 + 1 = 6
	1 2 4                    결과 : |8 - 6| = 2
)

예전에 이런 문제 어떻게 풀지 했는데.. 풀었다.
인덱스 활용해서 풀어야 겠다는 생각을 먼저 했다.
좌 -> 우 (0, 0) (1, 1) (2, 2)
우 -> 좌 (0, 2) (1, 1) (2, 0)
으로 진행되는데, 좌 -> 우는 인덱스가 같고 / 우 -> 좌는 x축은 값이 증가 y축은 값이 감소하고 있다.

만약, 예제의 인풋이 (3 x 3) 정해진 배열 하나만 주어졌다면 상수값을 넣어서(ex +1, -1)
인덱스 값을 주고, 문제를 풀었겠지만 테스트 케이스에는 다양한 값들이 있기 때문에 
좌 -> 우 / 우 -> 좌의 방향의 인덱스 값의 식을 구해야 했다.

1
2차원 배열이 인풋으로 주어졌다. 따라서 값을 사용하기 위해 리스트를 풀려면 반복문 2번이 필요하다.
2
그리고 리스트 인덱스는 0 부터 시작하니까, i와 j의 값을 일치하는 경우를 찾아야 했다. (좌 -> 우 방향)
풀이 작성하는 중에 생각해보니, i == j 로 조건문을 작성해도 됐었을 것 같다.
하지만 문제를 풀 때에는 아래와 같이 활용했다.
(arr배열 안 숫자의 수) - (arr배열 안 숫자의 수) + i  
(arr배열 안 숫자의 수) - (arr배열 안 숫자의 수) + j
i = 0, j = 0, 1, 2.. / i = 1, j = 0, 1, 2... / i = 2, j = 0, 1, 2...
돌아가면서 같을 때 좌 -> 우 결과값에 더해준다.
3
우 -> 좌 방향도 마찬가지로 인덱스 경우를 찾아서 정해줬다.
i는 마찬가지로 (arr배열 안 숫자의 수) - (arr배열 안 숫자의 수) + i
j는 len(a) - 1 - i
로 정해줬다.
j는 (i만큼 작아진다고 생각하면 될 것 같다.)
=> i == 0, j = 3 - 1 - 0 / i == 1, j = 3 - 1 -1 / i == 2, j = 3 - 1 - 2
           (0, 0)                  (1, 2)                 (2, 0)
           
인덱스를 활용한 접근법에 대해 학습할 수 있었다.
```

